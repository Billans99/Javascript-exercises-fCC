/* code to revisit */

/*              Javascript Algorithm To-Do list
1. Golf Code
2. Counting Cards
3. Record Collection
4. Iterate through an array with a For Loop
5. Nesting For Loops
6. Replace loops using recursion
7. Profile lookup
8. parseInt with radix
ES6
9. Use class Syntax to Define a Constructor Function
Youtube javascript classes on youtube and do more little exercises
10. revisit spread operator and youtube















                ES6 Notes!

1. Compare Scopes of the var and let Keywords
Notes: 
    Declaring var will declare it globally or locally. Let can be
    be declared in a block, statement or expression. Let was introduced in 
    ES6, never use var. Remember to use const always unless you think it should
    be mutable.

2. Mutate an Array Declared with const
Notes: 
    You can declare const s = [5, 7, 2]; but cant redeclare it later 
    saying const s = [2, 7, 5]. You can however mutate the array e.g. s[0] = 2;
    s[1] = 7; s[2] = 5; After this your array would now be [2, 7, 5]. Nice!

3. Prevent Object Mutation
Notes: 
    Object.freeze(object);
    Properties cannot be added, deleted or changed, as well as their
    corresponding values.

4. Use Arrow Functions to Write Concise Anonymous Functions
Notes:
    Functions are usually written like this: 

    const myFunc = function() {
        const myVar = "value";
        return myVar;
    }
    However, with ES6 arrow functions look like this:{
        const myFunc = () => {
            const myVar = "value";
            return myVar;
        }
    When there is no body function and only a return value it can be shortened
    even further to this: 
        const myFunc = () => "value";

5. Write Arrow Functions with Parameters
Notes:
    Arrow functions can also parse parameters e.g.
        const doubler = (item) => item * 2;
        doubler(4);
    If there is only one parameter, the () parentheses can be removed. e.g.
        const doubler = item => item * 2;
        doubler(4);
    Here's an example of a two parameter arrow function.
        const multiplier = (item, multi) => item * multi;
        multiplier(4, 2);

6. Set Default Parameters for Your Functions
Notes:
    ES6 has default parameters for functions. 
        const greeting = (name = "Anonymous") => "Hello " + name;

        console.log(greeting("John"));
        console.log(greeting());
    The first console.log will display the strings Hello John, and the second
    will return Hello Anonymous.

7. Use the Rest Parameter with Function Parameters
    const sum = (...args) => {
        const sum = (...args) => {
            let total = 0;
            for (let i = 0; i < args.length; i++) {
            total += args[i];
            }
            return total;
        }
        console.log(sum(1, 2, 3)); // 6

8. Use the Spread Operator to Evaluate Arrays In-Place
    const arr1 = ['JAN', 'FEB', 'MAR', 'APR', 'MAY'];
    let arr2;
    
    arr2 = [...arr1];  // Change this line
    
    console.log(arr2);

9. Use Destructuring Assignment to Extract Values from Objects
    const HIGH_TEMPERATURES = {
        yesterday: 75,
        today: 77,
        tomorrow: 80
    };
    
    // Only change code below this line
    const {today} = HIGH_TEMPERATURES;
    const {tomorrow} = HIGH_TEMPERATURES
    
    // const today = HIGH_TEMPERATURES.today;
    // const tomorrow = HIGH_TEMPERATURES.tomorrow;
    
    // Only change code above this line

10. Use Destructuring Assignment to Assign Variables from Objects
    const HIGH_TEMPERATURES = {
        yesterday: 75,
        today: 77,
        tomorrow: 80
    };
    
    // Only change code below this line
    const {highToday: today} = HIGH_TEMPERATURES;
    const {highTomorrow: tomorrow} = HIGH_TEMPERATURES;
    
    const {today: highToday} = HIGH_TEMPERATURES; 
    const {tomorrow: highTomorrow} = HIGH_TEMPERATURES;
    // const highToday = HIGH_TEMPERATURES.today;
    // const highTomorrow = HIGH_TEMPERATURES.tomorrow; 
    
    // Only change code above this line

11. Use Destructuring Assignment to Assign Variables from Nested Objects
    const LOCAL_FORECAST = {
        yesterday: { low: 61, high: 75 },
        today: { low: 64, high: 77 },
        tomorrow: { low: 68, high: 80 }
    };
    
    // Only change code below this line
    const { today: {low: lowToday, high: highToday}} = LOCAL_FORECAST;  
    
    // const lowToday = LOCAL_FORECAST.today.low;
    // const highToday = LOCAL_FORECAST.today.high;
    
    // Only change code above this line

12. Use Destructuring Assignment to Assign Variables from Arrays
    let a = 8, b = 6;
    // Only change code below this line
    [a, b] = [b, a];

13. Destructuring via rest elements
    function removeFirstTwo(list) {
        const [a, b, ...newArray] = list;
        return newArray;
    }
    
    const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const sourceWithoutFirstTwo = removeFirstTwo(source);

14. Use Destructuring Assignment to Pass an Object as a Function's
    Parameters
    const stats = {
        max: 56.78,
        standard_deviation: 4.34,
        median: 34.54,
        mode: 23.87,
        min: -0.75,
        average: 35.85
    };
    
    // Only change code below this line
    const half = ({ max, min }) => (max + min) / 2.0;
    
    // Only change code above this line

15. Create Strings using Template Literals
    Notes: 
    Template literals are performed with backticks `` and 
    ${variable/object} or ${object.prop}

    const result = {
        success: ["max-length", "no-amd", "prefer-arrow-functions"],
        failure: ["no-var", "var-on-top", "linebreak"],
        skipped: ["no-extra-semi", "no-dup-keys"]
    };
    function makeList(arr) {
        // Only change code below this line
        const failureItems = [];
        for (let i = 0; i < arr.length; i++) {
        failureItems.push(`<li class="text-warning">${arr[i]}</li>`)
    
        }
        
        // Only change code above this line
    
        return failureItems;
    }
    
    const failuresList = makeList(result.failure);
        
16. Write Concise Object Literal Declarations Using Object Property
    Shorthand
    Notes:
    Use object property shorthand with object literals

    const createPerson = (name, age, gender) => 
    // Only change code below this line
    ({name, age, gender});

  17. Write Concise Declarative Functions with ES6
  notes: 
    functions can be declared in an object. Also the word "function" and
    colon can be removed in ES6 to make it look cleaner to read.

    // Only change code below this line
    const bicycle = {
        gear: 2,
        setGear(newGear) {
        this.gear = newGear;
        }
    };
    // Only change code above this line
    bicycle.setGear(3);
    console.log(bicycle.gear);

  18. Use class Syntax to Define a Constructor Function
  Notes: 
    - Classes are a blueprint for creating (it can also be referred to as 
    instantiating) objects
    - Classes can also have functions which are called methods
    - Classes can also have properties
    - The most common thing that you do in the constructor is to set properties 
    on the class
    - to create a new instance of a class, use the key word "new" and then 
    the class name. E.g "new Spaceship"
    - the constructor a method is a special method that is called when 
    creating an instance of a class
    - when accessing properties in the class, you will need to use the 
    key word "this" e.g this.myProperty
    - They typically use UpperCamelCase as the name e.g. SpaceShuttle . 

    // Only change code below this line
    class Vegetable {
    constructor(name) {
        this.name = name; 
    }
    }
    // Only change code above this line

    const carrot = new Vegetable('carrot');
    console.log(carrot.name); // Should display 'carrot'

19. Use getters and setters to Control Access to an Object
Notes: 
    Getter functions are meant to simply return (get) the value of an object's 
    private variable to the user without the user directly accessing the 
    private variable.

    Setter functions are meant to modify (set) the value of an object's private
    variable based on the value passed into the setter function. This change 
    could involve calculations, or even overwriting the previous value 
    completely.
    Getters and setters are important as they hide internal implementation 
    details. It is convention to put underscore because private variable _. 
    e.g. _author . Although doing it does not make it private.

    // Only change code below this line
    class Thermostat {
    constructor(fahrenheit) {
        this._fahrenheit = fahrenheit;
    }

    get temperature() {
        return 5/9 * (this._fahrenheit - 32);
    }

    set temperature(celcius) {
    return this._fahrenheit = (celcius * 9.0) / 5 + 32;
    }
    }
    // Only change code above this line

    const thermos = new Thermostat(76); // Setting in Fahrenheit scale
    let temp = thermos.temperature; // 24.44 in Celsius
    thermos.temperature = 26;
    temp = thermos.temperature; // 26 in Celsius

20. Create a module script. 
Notes: 
    With the `<script="module" src="index.js"></script>` you
    can export files for use in other files or import the parts you need, 
    where you need.

    <html>
    <body>
        <!-- Only change code below this line -->
    <script type="module" src="index.js"></script>
        <!-- Only change code above this line -->
    </body>
    </html>

21. Use export to Share a Code Block
Notes: The last line of code is how to export. In the example below, 
    the function names are used as arguments for the export in order to export 
    the functions.

    const uppercaseString = (string) => {
    return string.toUpperCase();
    }

    const lowercaseString = (string) => {
    return string.toLowerCase()
    }

    export {uppercaseString, lowercaseString};

    Here's another example.

    const add = (x, y) => {
    return x + y;
    }

    export { add };


22. Reuse JavaScript Code Using import
Notes: 
    Following from the export code from above, in the new file where you want 
    to import what you exported, write

    import {uppercaseString, lowercaseString} from './string_functions.js';
    // Only change code above this line
    uppercaseString("hello");
    lowercaseString("WORLD!");

    Here's another example:
    import { add } from './math_functions.js';


23. Use * to Import Everything from a File
Notes:
    To import everything from a file: use,
    import * as stringFunctions from "./string_functions.js"
    // Only change code above this line

    stringFunctions.uppercaseString("hello");
    stringFunctions.lowercaseString("WORLD!");

    Here's another example. Dont forget it has to have ./ before file name.
    import * as myMathModule from "./math_functions.js";

24. Create an Export Fallback with export default
Notes:
    Default export adds a fallback value for a module or file.
    Below is a regular function:

    function subtract(x, y) {
    return x - y;
    } 
    Now we will add default export fallback
    export default function subtract(x, y) {
    return x - y;
    }

25. Import a Default Export
Notes: 
    Here is how to import a default export from question 24. 

    import subtract from "./math_functions.js"
    // Only change code above this line

    subtract(7,4);

26. Create a JavaScript Promise
Notes: promises are useed to make a promise, usually asynchronously.
    Promise is a constructor function so u use the new keyword e.g. 
    new Promise . Resolve parameter is used when you want your promise to 
    succeed. Reject is used when you want it to fail. 
    Here is an example below. 
    const makeServerRequest = new Promise((resolve, reject) => {

    });

27. Complete a Promise with resolve and reject
Notes: 
    A promise has three states: pending, fulfilled, rejected. The previous
    promise in Q.26 will always be pending because there's no way to complete
    the promise. 
    Here's an example of completing a promise with resolve and reject.
    const makeServerRequest = new Promise((resolve, reject) => {
    // responseFromServer represents a response from a server
    let responseFromServer;
        
    if(responseFromServer) {
    resolve("We got the data");
    } else {  
        reject("Data not received");
    }
    return responseFromServer;
    });

28. Handle a Fulfilled Promise with then
Notes: 
    Then is used to action it to do something when the promised is resolved. 
    In this case it console logs the result which is "We got the data"
    const makeServerRequest = new Promise((resolve, reject) => {
    // responseFromServer is set to true to represent a successful response from a server
    let responseFromServer = true;
        
    if(responseFromServer) {
        resolve("We got the data");
    } else {  
        reject("Data not received");
    }
    });

    makeServerRequest.then(result => {
    console.log(result);
    });

29. Handle a rejected promise with catch
Notes: 
    Catch is used to action a promise that is rejected. It happens right after
    the rejection is called. 
    Here's an example of how of syntax: 

    const makeServerRequest = new Promise((resolve, reject) => {
    // responseFromServer is set to false to represent an unsuccessful response from a server
    let responseFromServer = false;
        
    if(responseFromServer) {
        resolve("We got the data");
    } else {  
        reject("Data not received");
    }
    });

    makeServerRequest.then(result => {
    console.log(result);
    makeServerRequest.catch(error => {
    console.log(error);
    })
    });














                Started Debugging:

                Notes: 

Useful to console.log() 
    To check that previous calculations are
    performing correctly. Console also has console.warn() and console.clear().
    console.clear(); clears the log. 

Below are examples of typeof:
    let myVar1 = "3";
    let myVar2 = 2;
    console.log(typeof myVar1);
    console.log(typeof myVar2);
        string
        number

Javascript has 7 immutable datatypes:
    1. Boolean
    2. Null
    3. Undefined
    4. Number
    5. String
    6. Symbol
    7. BigInt

Spelling mistakes will show as reference error and myVar is not defined. 

Always add the second half of pair types () {} [] to avoid forgetting it 
later on.

Don't forget about using the escape key \ when using quotes in a string.
You can also decide to use the different quotes " ''

Remember:
    = is the assignment operator. Equality == and strict equality === are to
    check if something is equal to something else. 

    Dont forget to add parenthesis () to the end of a function or method when 
    delcaring it and also calling it.
    Usually the value returned at end of function is assigned to a variable.

 OBOE
    Off by one errors typically occur in an index of a string or array.
    e.g. for (let i = 1; i < myVar.length ; i++);
    This will skip the first element of the array. Correct code would be
    e.g. for (let i = 0; i < myVar.length; i++);

Caution when reinitialising variable inside a loop.
    In some loops you may need to reinitialize a variable INSIDE the loop
    or even take out the reinitialized variable when it is not needed.
    Example of initializing a variable e.g. let row = [];

Dreaded infinite loops.
    Loops need a terminal condition. Infinite loops are likely to freeze or 
    crash the browser. 

















                Data structures:

                Arrays()

Assign variable to element in an array 
    const myArray = [1, 2, 3, 4, 5];
    const myVar = myArray[1];
    myVar is now = 2

Change an element inside array index
    const myArray = [1, 2, 3, 4, 5];
    myArray[1] = "Billy";
    console.log(myArray)
    [1, "Billy, 3, 4, 5];

Add elements to the start of array
    myArray.unshift("Billy", 7);

Add elements to end of array
    myArray.push("myString", 7);

Remove element from start of array. 
    Note: it can only remove one element.
    myArray.shift();

Remove element from end of array.
    Note: it can only remove one element.
    myArray.pop();

Return or assign pop() or shift value to variable
    let myArray = [1, 2, 3, 4];
    let popped = myArray.pop();

Remove middle of array or multiple elements using splice()
Notes: ONLY USABLE IN ARRAYS
    let myArray = ["I", "am", "feeling", "really", "happy"]
    let newArray = myArray.splice(3, 2);

    console.log(newArray);
    ["really", "happy"]
    console.log(myArray)
    ["I", "am", "feeling"];

Remove middle elements of array to swap elements using splice()
    const numbers = [10, 11, 12, 12, 15];
    const startIndex = 3;
    const amountToDelete = 1;

    numbers.splice(startIndex, amountToDelete, 13, 14);
    console.log(numbers);

Copy elements of array without changing original using slice()
Notes: CAN BE USED WITH STRINGS TOO
    Note: 
    slice(param1, param2) takes in two parameters, first is when to start
    and the second is when to stop. It excludes the element it stops at. 
    
    let weatherConditions = ['rain', 'snow', 'sleet', 'hail', 'clear'];
    let todaysWeather = weatherConditions.slice(1, 3);

    console.log(todaysWeather);
    ["snow", "sleet"]
    console.log(weatherConditions);
    ['rain', 'snow', 'sleet', 'hail', 'clear'];

Use spread ... to copy another array into another variable.
It is used to spread or expand iterable objects (like arrays or strings) 
into individual elements.
Some use cases: 
Copying arrays -
    let thisArray = [true, true, undefined, false, null];
    let thatArray = [...thisArray];
merging arrays -
    const arr1 = [1, 2];
    const arr2 = [3, 4];
    const mergedArray = [...arr1, ...arr2];
    console.log(mergedArray); // [1, 2, 3, 4]
Adding elements to an array -
    const originalArray = [1, 2, 3];
    const newArray = [...originalArray, 4, 5];
    console.log(newArray); // [1, 2, 3, 4, 5]
Using with function arguments -
    function sum(a, b, c) {
    return a + b + c;
    }
    const numbers = [1, 2, 3];
    const result = sum(...numbers);
    console.log(result); // 6
Copying objects -
    const originalObj = { name: 'John', age: 30 };
    const copyObj = { ...originalObj };
    console.log(copyObj); // { name: 'John', age: 30 }
Merging objects -
    const obj1 = { a: 1, b: 2 };
    const obj2 = { b: 3, c: 4 };
    const mergedObj = { ...obj1, ...obj2 };
    console.log(mergedObj); // { a: 1, b: 3, c: 4 }

Check For The Presence of an Element With indexOf()
    notes: It will return -1 if the element is not inside array, and 
    it will return the place in the index if element is inside array.

    let fruits = ['apples', 'pears', 'oranges', 'peaches', 'pears'];
    fruits.indexOf('dates');
    fruits.indexOf('oranges');
    fruits.indexOf('pears');

    indexOf('dates') returns -1, indexOf('oranges') returns 2,and 
    indexOf('pears') returns 1 (the first index at which each element exists).

Iterate Through All an Array's Items Using For Loops using every(),
forEach(), map()
    function greaterThanTen(arr) {
    let newArr = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] > 10) {
        newArr.push(arr[i]);
        }
    }
    return newArr;
    }
    greaterThanTen([2, 12, 8, 14, 80, 0, 1]);

Create complex multi-dimensional arrays
    Notes: The very first square bracket is the first level of a 
    multi-dimensional (nested array) the ones that come after are
    the next level. Look at where "Array" is on the following examples.
    First level: let myArr = ["Array"];
    Second level: let myArr = ["Bob", "Billy", ["Array"]];
    Third level: let myArr = ["Bob", "Billy", ["Jean", "Jack", ["Array"]]];

Sort an array in ascending order:
    let myArray = [6, 7, 1, 4, 9]
    myArray.sort() = [1, 4, 6, 7, 9]

    let myFruits = [banana, orange, apple];
    myFruits.sort() = [apple, banana, orange];
        




                    Objects!

Notes:
    Objects are property-value stores. An intuitive way to structure data. 
    They have a very fast look-up time. 

Add Properties (keys) and their corresponding values to objects
Notes: Don't forget when using bracket notation to put strings '' around the 
property (key).
    1. tekkenCharacter.origin = 'South Korea';

    2. tekkenCharacter['hair color'] = 'dyed orange';

Notes about objects:
properties themselves can include parentheses {} after a property
to further nest data inside a single property. These values can contain
any data type that Javascript supports. The value of id below is a number, 
value of date is a string, and the value of data is an object. 
In order to modify busy to 10, nestedObject.data.onlineStatus.busy = 10; e.g.
    let nestedObject = {
    id: 28802695164,
    date: 'December 31, 2016',
    data: {
        totalUsers: 99,
        online: 80,
        onlineStatus: {
        active: 67,
        away: 13,
        busy: 8
        }
    }
    };

Access Property names with bracket notations:
    let foods = {
    apples: 25,
    oranges: 32,
    plums: 28,
    bananas: 13,
    grapes: 35,
    strawberries: 27
    };

    function checkInventory(scannedItem) {
    // Only change code below this line
    let scanned = foods[scannedItem]
    // Only change code above this line
    return scanned;
    }
    console.log(checkInventory("apples"));

Delete Object properties using Delete keyword
    To remove apples property (also known as key) from foods object, see below:
    delete foods.apples;

    Bracket notation can also work e.g.
    delete foods['oranges'];

Check if an Object has a Property:
Notes: Javascript has two ways to check. 1. hasOwnProperty() and 2. in keyword.
e.g.
    1. users.hasOwnProperty('Alan');

    2. 'Alan' in users;

Iterate through all keys in an object with a for in loop
    const refrigerator = {
    'milk': 1,
    'eggs': 12,
    };

    for (const food in refrigerator) {
    console.log(food, refrigerator[food]);
    }
    This code logs milk 1 and eggs 12, with each key-value pair on its own line.

Generate an Array of All Object Keys with Object.keys()
Notes: Gather all properties in an object and put them into an array: Object.keys();
The targeted object is used as an argument. Object.keys(myObject);
    let users = {
    Alan: {
        age: 27,
        online: false
    },
    Jeff: {
        age: 32,
        online: true
    },
    Sarah: {
        age: 48,
        online: false
    },
    Ryan: {
        age: 19,
        online: true
    }
    };

    function getArrayOfUsers(obj) {
    // Only change code below this line
    const allUsers = Object.keys(obj);
    return allUsers;
    // Only change code above this line
    }

    console.log(getArrayOfUsers(users));

Modify an array stored in an object:
    let user = {
    name: 'Kenneth',
    age: 28,
    data: {
        username: 'kennethCodesAllDay',
        joinDate: 'March 26, 2016',
        organization: 'freeCodeCamp',
        friends: [
        'Sam',
        'Kira',
        'Tomo'
        ],
        location: {
        city: 'San Francisco',
        state: 'CA',
        country: 'USA'
        }
    }
    };

    function addFriend(userObj, friend) {
    // Only change code below this line
    userObj.data.friends.push(friend);
    return userObj.data.friends
    // Only change code above this line
    }

    console.log(addFriend(user, 'Pete'));




    







    



    
                Basic Algorithym Scripting

Convert Celsius to Fahrenheit
    function convertCtoF(celsius) {
    let fahrenheit;
    fahrenheit = celsius * (9 / 5) + 32;
    return fahrenheit;
    }

    convertCtoF(30);

Reverse a String to make "olleh"
    function reverseString(str) {
    let newStr = "";
    for (let i = str.length -1; i >= 0; i--) {
    newStr += str[i];
    }
    return newStr;

    }
    reverseString("hello");

Factorialize a Number
Notes: 
If the integer is represented with the letter n, a factorial is the 
product of all positive integers less than or equal to n.
Factorials are often represented with the shorthand notation n!
For example: 5! = 1 * 2 * 3 * 4 * 5 = 120
    function factorialize(num) {
    let product = 1;
    for (let i = 1; i <= num; i++) {
        product *= i;
    }
    return product;
    }

    factorialize(5);

Find the Longest Word in a String
    function findLongestWordLength(str) {
    let wordsArray = str.split(" ");
    let maxLength = 0;

    for (let i = 0; i < wordsArray.length; i++) {
        if (wordsArray[i].length > maxLength) {
        maxLength = wordsArray[i].length;
        }
    }

    return maxLength;
    }

    findLongestWordLength("The quick brown fox jumped over the lazy dog");

Return Largest number in arrays
    function largestOfFour(arr) {
    let results = [];
    for (let i = 0; i < arr.length; i++) {
    let largestNum = arr[i][0];
        for (let j = 1; j < arr[i].length; j++) {
        if (arr[i][j] > largestNum) {
            largestNum = arr[i][j];
        }
        }
        results[i] = largestNum;
    } 
    return results;
    }

    largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);

Confirm the Ending of string
    function confirmEnding(str, target) {
    return str.slice(str.length - target.length) == target;

    }
    confirmEnding("Bastian", "n"); 

Repeat a string Repeat a string
    function repeatStringNumTimes(str, num) {
    let combined = "";
    for (let i = 0; i < num; i++) {
    combined += str;
    }
    return combined;
    }

    repeatStringNumTimes("abc", 3);

Truncate a String
    function truncateString(str, num) {
    if (str.length > num) {
        return str.slice(0, num) + "...";
    } else {
        return str;
    }
    }

    truncateString("A-tisket a-tasket A green and yellow basket", 8);

Finders Keepers
    function findElement(arr, func) {
    let num = 0;
    for (let i = 0; i < arr.length; i++) {
        num = arr[i];
        if (func(num)) {
        return num;
        } 
    }
    return undefined;
    }

    findElement([1, 2, 3, 4], num => num % 2 === 0);

Boo who
Check if a value is classified as a boolean primitive Boolean primitives are
true and false.
    function booWho(bool) {
    if (bool === true) {
        return true;
    } else if (bool === false) {
        return true;
    } else {
        return false;
    }
    }

    booWho(null);

Title Case a Sentence
Return provided string with each first letter capitalized and the rest lowercase
    function titleCase(str) {
    
    // console.log(lowerCaseStr);
    let arr = str.split(' '); 

    for (let i = 0; i < arr.length; i++) {
    arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].slice(1).toLowerCase();       
    } 

    return arr.join(' '); 
    }

Slice and Splice
Copy the first array into the second, by the index specified. 
    function insertArrayAt(array1, array2, index) {
    // Make a copy of the second array to keep the input arrays unchanged
    const resultArray = array2.slice();

    // Insert elements from the first array into the result array using concat and splice
    resultArray.splice(index, 0, ...array1);

    return resultArray;
    }

    // Example usage:
    const array1 = [1, 2, 3];
    const array2 = [4, 5, 6];
    const index = 2;
    const result = insertArrayAt(array1, array2, index);

    console.log(result); // Output: [4, 5, 1, 2, 3, 6]

Falsy Bouncer
Remove all falsy values from an array
Notes: Falsy values are: False, null, 0, "", undefined, NaN

    function bouncer(arr) {
    const trueArray = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i]) {
        trueArray.push(arr[i]);
        }
    }
    return trueArray;
    }
    bouncer([7, "ate", "", false, 9]);

    OR 

    function bouncer(arr) {
    return arr.filter(Boolean);
    }

Where do I Belong
Return the lowest index at which a value (second argument) 
should be inserted into an array (first argument) once it has been sorted. 
The returned value should be a number.
    function getIndexToIns(arr, num) {
    arr.sort((a, b) => a - b);

    for (let i = 0; i < arr.length; i++) {
        if (arr[i] >= num) return i;
    }

    return arr.length;
    }
    getIndexToIns([40, 60], 50);

Mutations
Return true if the string in the first element of the array contains 
all of the letters of the string in the second element of the array.
    function mutation(arr) {
    const firstWord = arr[0].toLowerCase();
    const secondWord = arr[1].toLowerCase();

    for (let i = 0; i < secondWord.length; i++) {
    if (firstWord.indexOf(secondWord[i]) === -1) {
        return false;
        }
    } 
    return true;
    }

    mutation(["hello", "hey"]);

Chunky Monkey
    function chunkArrayInGroups(arr, size) {
    const result = [];

    for (let i = 0; i < arr.length; i += size) {
        result.push(arr.slice(i, i + size))
    }
    return result;
    }

    chunkArrayInGroups(["a", "b", "c", "d"], 2);



















                Object Oriented Programming
Notes:

OOP, or Object Oriented Programming, is one of the major approaches to
the software development process. In OOP, objects and classes organize 
code to describe things and what they can do. In this course, you'll 
learn the basic principles of OOP in JavaScript, including the this
keyword, prototype chains, constructors, and inheritance.

Think about things people see every day, like cars, shops, and birds. 
These are all objects: tangible things people can observe and interact with.
What are some qualities of these objects? A car has wheels. 
Shops sell items. Birds have wings. These qualities, or properties, define 
what makes up an object. Note that similar objects share the same properties, 
but may have different values for those properties. For example, all cars 
have wheels, but not all cars have the same number of wheels. Objects in 
JavaScript are used to model real-world objects, giving them properties 
and behavior just like their real-world counterparts. Here's an example 
using these concepts to create a duck object:

Create a basic JavaScript Object
    let dog = {
    name: 'henry',
    numLegs: 4
    };

Use Dot Notation to Access the Properties of an Object
    let dog = {
    name: "Spot",
    numLegs: 4
    };
    // Only change code below this line
    console.log(dog.name);
    console.log(dog.numLegs);

Create a method on an object
notes: methods are functions that are used in class and objects
    let dog = {
    name: "Spot",
    numLegs: 4,
    sayLegs: function() {return "This dog has " + dog.numLegs + " legs."}

    };
    dog.sayLegs();

Make Code More Reusable with the THIS Keyword
    let dog = {
    name: "Spot",
    numLegs: 4,
    sayLegs: function() {return "This dog has " + this.numLegs + " legs.";}
    };

    dog.sayLegs();





            Constructor functions

Define a Constructor Function
    function Dog() {
    this.name = 'yoza',
    this.color = 'black',
    this.numLegs = 4
    }

Use a Constructor to Create Objects
    function Dog() {
    this.name = "Rupert";
    this.color = "brown";
    this.numLegs = 4;
    }

    let hound = new Dog();

Extend Constructors to Receive Arguments
Notes: If you want different dogs that aren't brown and named Rupert, you can 
have the constructor properties take in parameters.
    function Dog(name, color) {
    this.name = name;
    this.color = color;
    this.numLegs = 4;
    }

    let terrier = new Dog('Cookie', 'brown');

Verify an Object's Constructor with instanceof
Notes: Anytime a constructor function creates a new object, that object is
said to be an instance of its constructor. instanceOf return true or false.
    function House(numBedrooms) {
    this.numBedrooms = numBedrooms;
    }

    let myHouse = new House(4);

    myHouse instanceof House;

Understand Own Properties
Add the own properties of canary to the array ownProps.
The following code adds all of the own properties of canary to the array ownProps
    function Bird(name) {
    this.name = name;
    this.numLegs = 2;
    }

    let canary = new Bird("Tweety");
    let ownProps = [];

    for (let property in canary) {
    if (canary.hasOwnProperty(property)) {
        ownProps.push(property);
    }
}

Use Prototype Properties to Reduce Duplicate Code
Prototypes properties are used when that property will be applicable to all
instances of that object.
    function Dog(name) {
    this.name = name;
    Dog.prototype.numLegs = 4;
    }

    let beagle = new Dog("Snoopy");

Iterate Over All Properties
Here is how you add duck's own properties to the array ownProps and prototype
properties to the array prototypeProps:
    function Dog(name) {
    this.name = name;
    }

    Dog.prototype.numLegs = 4;

    let beagle = new Dog("Snoopy");

    let ownProps = [];
    let prototypeProps = [];

    // Only change code below this line
    for (let property in beagle) {
    if (beagle.hasOwnProperty(property)) {
        ownProps.push(property)
    } else {
        prototypeProps.push(property);
    }
    }
    console.log(ownProps);
    console.log(prototypeProps);

Understand the Constructor Property
Notes: duck and beagle have its own constructor property. Here's how to check
if duck is from Bird constructor object and if beagle is from the Dog constructor
object.
let duck = new Bird();
let beagle = new Dog();
console.log(duck.constructor === Bird); 
console.log(beagle.constructor === Dog);
The answers will print true for both.
Since these constructor properties can be overrided, it's better to use instanceOf.
Write a join dogfraternity function:
    function Dog(name) {
    this.name = name;
    }

    function joinDogFraternity(candidate) {
    if (candidate.constructor === Dog) {
        return true;
    } else {
        return false;
    }
    }

Change the Prototype to a New Object
Up until now we would add prototype props individually e.g.
Bird.prototype.numLegs = 2;
A more efficient way is to set the prototype to a new object that already contains
the properties. This way, the properties are added all at once e.g.
    function Dog(name) {
    this.name = name;
    }

    Dog.prototype = {

    };

    Dog.prototype = {
    numLegs: 4,
    eat: function() {
        console.log('yum yum yum')
    },
    describe: function() {
        console.log('I am ' + this.name + 'type of dawg!')
    }
    };

Remember to Set the Constructor Property when Changing the Prototype
Notes: When manually making prototype property, it will override the constructor
property. So duck will no longer be say 'true' when asked if its from the bird
constructor. However you can still say ask for 'instanceof'. However, just add
the constructor manually afterwards to the prototype.
    function Dog(name) {
    this.name = name;
    }

    // Only change code below this line
    Dog.prototype = {
    constructor: Dog,
    numLegs: 4,
    eat: function() {
        console.log("nom nom nom");
    },
    describe: function() {
        console.log("My name is " + this.name);
    }
    };

Understand Where an Object’s Prototype Comes From using isPrototypeOf
Use isPrototypeOf to check the prototype of beagle
    function Dog(name) {
    this.name = name;
    }

    let beagle = new Dog("Snoopy");

    Dog.prototype.isPrototypeOf(beagle);

Understand the Prototype Chain
Notes: all objects have a prototype. Because prototype is an object, a 
prototype has a prototype in itself, which is 'object'. 
    function Dog(name) {
    this.name = name;
    }

    let beagle = new Dog("Snoopy");

    Dog.prototype.isPrototypeOf(beagle);  // yields true

    Object.prototype.isPrototypeOf(Dog.prototype);

Use Inheritance So You Don't Repeat Yourself
Notes: There's a principle in programming called Don't Repeat Yourself (DRY). 
Instead of repeating like this:

function Cat(name) {
  this.name = name;
}

Cat.prototype = {
  constructor: Cat,
  eat: function() {
    console.log("nom nom nom");
  }
};

function Bear(name) {
  this.name = name;
}

Bear.prototype = {
  constructor: Bear,
  eat: function() {
    console.log("nom nom nom");
  }
};

function Animal() { }

Animal.prototype = {
  constructor: Animal,
  
};
Instead of that, take the eat function out of bear and cat prototypes, and just
add it to the animal supertype (parent) like this:
    function Cat(name) {
    this.name = name;
    }

    Cat.prototype = {
    constructor: Cat,
    };

    function Bear(name) {
    this.name = name;
    }

    Bear.prototype = {
    constructor: Bear,
    };

    function Animal() { }

    Animal.prototype = {
    constructor: Animal,
    eat: function() {
        console.log("nom nom nom");
    }
    };

Inherit Behaviors from a Supertype
    function Animal() { }

    Animal.prototype = {
    constructor: Animal,
    eat: function() {
        console.log("nom nom nom");
    }
    };

    // Only change code below this line
    let duck = Object.create(Animal.prototype);
    let beagle = Object.create(Animal.prototype);
    duck.eat(); // = nom nom nom
    console.log(duck instanceof Animal); // = true

Set the Child's Prototype to an Instance of the Parent
Notes: This challenge covers the next step: set the prototype of the subtype 
(or child)—in this case, Dog—to be an instance of Animal. Remember that the 
prototype is like the "recipe" for creating an object. In a way, the recipe 
for Dog now includes all the key "ingredients" from Animal. Dog inherits all
of Animal's properties, including the eat method.
    function Animal() { }

    Animal.prototype = {
    constructor: Animal,
    eat: function() {
        console.log("nom nom nom");
    }
    };

    function Dog() { }

    // Only change code below this line
    Dog.prototype = Object.create(Animal.prototype);

    let beagle = new Dog();

Reset an Inherited Constructor Property
Notes: When an object inherits its prototype from another object, it also 
inherits the supertype's constructor property. e.g.
function Bird() { }
Bird.prototype = Object.create(Animal.prototype);
let duck = new Bird();
duck.constructor

But duck and all instances of Bird should show that they were constructed by 
Bird and not Animal. To do so, you can manually set the constructor property 
of Bird to the Bird object:
    Bird.prototype.constructor = Bird;
    duck.constructor


Add Methods After Inheritance
Notes: A constructor function that inherits its prototype object from a 
supertype constructor function can still have its own methods in addition 
to inherited methods. Here's how to add .fly method to bird prototype.
Bird.prototype.fly = function() {
console.log("I'm flying!");
};
Now you can use that method by going 
duck.fly();
Add all necessary code so the Dog object inherits from Animal and the Dog's 
prototype constructor is set to Dog. Then add a bark() method to the Dog 
object so that beagle can both eat() and bark(). The bark() method should 
print Woof! to the console.
    function Animal() { }
    Animal.prototype.eat = function() { console.log("nom nom nom"); };

    function Dog() { }

    // Only change code below this line
    Dog.prototype = Object.create(Animal.prototype);
    Dog.prototype.bark = function() {
    console.log('Woof!');
    }
    Dog.prototype.constructor = Dog;

    // Only change code above this line

    let beagle = new Dog();


Override Inherited Methods
Notes: Previously we learned to reference a child's prototype to its parents 
prototype e.g. 
ChildObject.prototype = Object.create(ParentObject.prototype);

Then the child object could receiveits own methods by chaining it
to its own prototype e.g.
ChildObject.prototype.methodName = function() {...};

It's possible to override an inherited method. It's done the same way - by 
adding a method to ChildObject.prototype using the same method name as the 
one to override. If you have an instance let duck = new Bird(); and you call duck.eat(), this 
is how JavaScript looks for the method on the prototype chain of duck:
1. duck => Is eat() defined here? No.
2. Bird => Is eat() defined here? => Yes. Execute it and stop searching.
3. Animal => eat() is also defined, but JavaScript stopped searching before reaching this level.
4. Object => JavaScript stopped searching before reaching this level.
Here's an example of Bird overriding the eat() method 
inherited from Animal:
    function Animal() { }
    Animal.prototype.eat = function() {
    return "nom nom nom";
    };
    function Bird() { }

    Bird.prototype = Object.create(Animal.prototype);

    Bird.prototype.eat = function() {
    return "peck peck peck";
    };


Use a Mixin to Add Common Behavior Between Unrelated Objects
Notes: As you have seen, behavior is shared through inheritance. However, there are cases when 
inheritance is not the best solution. Inheritance does not work well for unrelated objects like 
Bird and Airplane. They can both fly, but a Bird is not a type of Airplane and vice versa.

For unrelated objects, it's better to use mixins. A mixin allows other objects to use a collection 
of functions.
    let flyMixin = function(obj) {
    obj.fly = function() {
        console.log("Flying, wooosh!");
    }
    };
    The flyMixin takes any object and gives it the fly method.
    let bird = {
    name: "Donald",
    numLegs: 2
    };

    let plane = {
    model: "777",
    numPassengers: 524
    };

    flyMixin(bird);
    flyMixin(plane);

    Here bird and plane are passed into flyMixin, which then assigns the fly function to each object.
    Now bird and plane can both fly:

    bird.fly();
    plane.fly();


Use Closure to Protect Properties Within an Object from Being Modified Externally
Notes: In the previous challenge, bird had a public property name. It is considered public because 
it can be accessed and changed outside of bird's definition. Therefore, any part of your code can 
easily change the name of bird to any value. Think about things like passwords and bank accounts 
being easily changeable by any part of your codebase. That could cause a lot of issues. The simplest 
way to make this public property private is by creating a variable within the constructor function. 
This changes the scope of that variable to be within the constructor function versus available globally.
    function Bird() {
    let hatchedEgg = 10;

    this.getHatchedEggCount = function() { 
        return hatchedEgg;
    };
    }
    let ducky = new Bird();
    ducky.getHatchedEggCount();
    Here getHatchedEggCount is a privileged method, because it has access to the private variable hatchedEgg. 
    This is possible because hatchedEgg is declared in the same context as getHatchedEggCount. In JavaScript, 
    a function always has access to the context in which it was created. This is called closure. 
    Here's another example of it:
    function Bird() {
    let weight = 15;

    this.getWeight = function() {
    return weight;
    }

    }

Understand the Immediately Invoked Function Expression (IIFE)
Notes: A common pattern in JavaScript is to execute a function as soon as it is declared:
    (function () {
    console.log("Chirp, chirp!");
    })();
This is an anonymous function expression that executes right away, and outputs Chirp, chirp! immediately.
Note that the function has no name and is not stored in a variable. The two parentheses () at the end of 
the function expression cause it to be immediately executed or invoked. This pattern is known as an
immediately invoked function expression or IIFE. Here's another example:
    (function() {
    console.log('A cozy nest is ready');
    })();

Use an IIFE to Create a Module
An immediately invoked function expression (IIFE) is often used to group related functionality into a single
object or module. For example, an earlier challenge defined two mixins:
function glideMixin(obj) {
  obj.glide = function() {
    console.log("Gliding on the water");
  };
}
function flyMixin(obj) {
  obj.fly = function() {
    console.log("Flying, wooosh!");
  };
}

We can group these mixins into a module as follows:
    let motionModule = (function () {
    return {
        glideMixin: function(obj) {
        obj.glide = function() {
            console.log("Gliding on the water");
        };
        },
        flyMixin: function(obj) {
        obj.fly = function() {
            console.log("Flying, wooosh!");
        };
        }
    }
    })();
    Note that you have an immediately invoked function expression (IIFE) that returns an object motionModule. 
    This returned object contains all of the mixin behaviors as properties of the object. The advantage of 
    the module pattern is that all of the motion behaviors can be packaged into a single object that can then 
    be used by other parts of your code. Here is an example using it:

    motionModule.glideMixin(duck);
    duck.glide();
    Here's another example: 
    let funModule = (function () {
    return {
        isCuteMixin: function(obj) {
        obj.isCute = function() {
            return true;
        };
        },
        singMixin: function(obj) {
        obj.sing = function() {
            console.log('Singing to an awesome tune');
        };
        }
    }
    })();
















                Functional Programming

Learn About Functional Programming
Functional programming is a style of programming where solutions are simple, isolated functions, without 
any side effects outside of the function scope: INPUT -> PROCESS -> OUTPUT

Functional programming is about:
1. Isolated functions - there is no dependence on the state of the program, which includes global variables 
    that are subject to change

2. Pure functions - the same input always gives the same output

3. Functions with limited side effects - any changes, or mutations, to the state of the program outside 
    the function are carefully controlled

In the code editor, the prepareTea and getTea functions are already defined for you. Call the getTea 
function to get 40 cups of tea for the team, and store them in the tea4TeamFCC variable.

    // Function that returns a string representing a cup of green tea
    const prepareTea = () => 'greenTea';

    
    Given a function (representing the tea type) and number of cups needed, the
    following function returns an array of strings (each representing a cup of
    a specific type of tea).
    */
    const getTea = (numOfCups) => {
        const teaCups = [];
    
        for(let cups = 1; cups <= numOfCups; cups += 1) {
        const teaCup = prepareTea();
        teaCups.push(teaCup);
        }
        return teaCups;
    };
    
    // Only change code below this line
    const tea4TeamFCC = getTea(40);
    // Only change code above this line */
    /*

Understand Functional Programming Terminology
Notes: We will use the previous example of tea but now the FCC team will be able to pick between green
tea and black tea. 

But first, let's cover some functional terminology:
Callbacks are the functions that are slipped or passed into another function to decide the invocation 
of that function. You may have seen them passed to other methods, for example in filter, the callback 
function tells JavaScript the criteria for how to filter an array.

Functions that can be assigned to a variable, passed into another function, or returned from another 
function just like any other normal value, are called first class functions. In JavaScript, all functions 
are first class functions.

The functions that take a function as an argument, or return a function as a return value, are called higher 
order functions.

When functions are passed in to or returned from another function, then those functions which were passed in 
or returned can be called a lambda.
    // Function that returns a string representing a cup of green tea
    const prepareGreenTea = () => 'greenTea';

    // Function that returns a string representing a cup of black tea
    const prepareBlackTea = () => 'blackTea';

    /*
    Given a function (representing the tea type) and number of cups needed, the
    following function returns an array of strings (each representing a cup of
    a specific type of tea).
    */
    const getTea = (prepareTea, numOfCups) => {
        const teaCups = [];
    
        for(let cups = 1; cups <= numOfCups; cups += 1) {
        const teaCup = prepareTea();
        teaCups.push(teaCup);
        }
        return teaCups;
    };
    
    // Only change code below this line
    const tea4GreenTeamFCC = getTea(prepareGreenTea,  27);
    const tea4BlackTeamFCC = getTea(prepareBlackTea, 13);
    // Only change code above this line
    
    console.log(
        tea4GreenTeamFCC,
        tea4BlackTeamFCC
    );

    /*

Understand the Hazards of Using Imperative Code
Notes: Functional programming is a good habit. It keeps your code easy to manage, and saves you from sneaky bugs. 
But before we get there, let's look at an imperative approach to programming to highlight where you may 
have issues.

In English (and many other languages), the imperative tense is used to give commands. Similarly, an 
imperative style in programming is one that gives the computer a set of statements to perform a task.

Often the statements change the state of the program, like updating global variables. A classic example is 
writing a for loop that gives exact directions to iterate over the indices of an array.

In contrast, functional programming is a form of declarative programming. You tell the computer what you 
want done by calling a method or function.

JavaScript offers many predefined methods that handle common tasks so you don't need to write out how the 
computer should perform them. For example, instead of using the for loop mentioned above, you could call 
the map method which handles the details of iterating over an array. This helps to avoid semantic errors, 
like the "Off By One Errors" that were covered in the Debugging section.

Consider the scenario: you are browsing the web in your browser, and want to track the tabs you have opened. 
Let's try to model this using some simple object-oriented code.

A Window object is made up of tabs, and you usually have more than one Window open. The titles of each open 
site in each Window object is held in an array. After working in the browser (opening new tabs, merging 
windows, and closing tabs), you want to print the tabs that are still open. Closed tabs are removed from the 
array and new tabs (for simplicity) get added to the end of it.

The code editor shows an implementation of this functionality with functions for tabOpen(), tabClose(), and 
join(). The array tabs is part of the Window object that stores the name of the open pages.

    // tabs is an array of titles of each site open within the window
    const Window = function(tabs) {
    this.tabs = tabs; // We keep a record of the array inside the object
    };

    // When you join two windows into one window
    Window.prototype.join = function(otherWindow) {
    this.tabs = this.tabs.concat(otherWindow.tabs);
    return this;
    };

    // When you open a new tab at the end
    Window.prototype.tabOpen = function(tab) {
    this.tabs.push('new tab'); // Let's open a new tab for now
    return this;
    };

    // When you close a tab
    Window.prototype.tabClose = function(index) {

    // Only change code below this line

    const tabsBeforeIndex = this.tabs.splice(0, index); // Get the tabs before the tab
    const tabsAfterIndex = this.tabs.splice(1); // Get the tabs after the tab

    this.tabs = tabsBeforeIndex.concat(tabsAfterIndex); // Join them together

    // Only change code above this line

    return this;
    };

    // Let's create three browser windows
    const workWindow = new Window(['GMail', 'Inbox', 'Work mail', 'Docs', 'freeCodeCamp']); // Your mailbox, 
    drive, and other work sites
    const socialWindow = new Window(['FB', 'Gitter', 'Reddit', 'Twitter', 'Medium']); // Social sites
    const videoWindow = new Window(['Netflix', 'YouTube', 'Vimeo', 'Vine']); // Entertainment sites

    // Now perform the tab opening, closing, and other operations
    const finalTabs = socialWindow
    .tabOpen() // Open a new tab for cat memes
    .join(videoWindow.tabClose(2)) // Close third tab in video window, and join
    .join(workWindow.tabClose(1).tabOpen());
    console.log(finalTabs.tabs);

Avoid Mutations and Side Effects Using Functional Programming
Notes: In the example below, we make sure fixedValue doesn't change by assigning the variable newValue to 
the return of the call function, that way fixed value doesn't change.  If you haven't already figured it out, the 
issue in the previous challenge was with the splice call in the  tabClose() function. Unfortunately, splice 
changes the original array it is called on, so the second call to it used a modified array, and gave unexpected 
results.

Recall that in functional programming, changing or altering things is called mutation, and the outcome is called a 
side effect. A function, ideally, should be a pure function, meaning that it does not cause any side effects.
    // The global variable
    let fixedValue = 4;

    function incrementer() {
    // Only change code below this line
    return fixedValue + 1;
    // Only change code above this line
    }
    
    let newValue = incrementer();

Pass Arguments to Avoid External Dependence in a Function
Notes: Another principle of functional programming is to always declare your dependencies explicitly. This means 
if a function depends on a variable or object being present, then pass that variable or object directly into the 
function as an argument.

There are several good consequences from this principle. The function is easier to test, you know exactly what 
input it takes, and it won't depend on anything else in your program.

This can give you more confidence when you alter, remove, or add new code. You would know what you can or cannot 
change and you can see where the potential traps are.

Finally, the function would always produce the same output for the same set of inputs, no matter what part of the 
code executes it.
    // The global variable
    let fixedValue = 4;

    // Only change code below this line
    function incrementer(variable) {
    return fixedValue + 1;
    // Only change code above this line
    }
    let newValue = incrementer();

Refactor Global Variables Out of Functions
So far, we have seen two distinct principles for functional programming:

Don't alter a variable or object - create new variables and objects and return them if need be from a function. 
Hint: using something like const newArr = arrVar, where arrVar is an array will simply create a reference to the 
existing variable and not a copy. So changing a value in newArr would change the value in arrVar.

Declare function parameters - any computation inside a function depends only on the arguments passed to the 
function, and not on any global object or variable.

Adding one to a number is not very exciting, but we can apply these principles when working with arrays or more 
complex objects.
    // The global variable
    const bookList = ["The Hound of the Baskervilles", "On The Electrodynamics of Moving Bodies", "Philosophiæ 
    Naturalis Principia Mathematica", "Disquisitiones Arithmeticae"];

    // Change code below this line
    function add(arr, bookName) {
    let newArr = [...arr];
    newArr.push(bookName);
    return newArr;
    
    // Change code above this line
    }

    // Change code below this line
    function remove(arr, bookName) {
    let newArr = [...arr]
    let book_index = newArr.indexOf(bookName);
    if (book_index >= 0) {

        newArr.splice(book_index, 1);
        return newArr;

        // Change code above this line
        }
    }

Use the map Method to Extract Data from an Array
Notes: So far we have learned to use pure functions to avoid side effects in a program. Also, we have seen the
value in having a function only depend on its input arguments. Functions are considered first class objects in 
JavaScript, which means they can be used like any other object. They can be saved in variables, stored in an 
object, or passed as function arguments.

The map method iterates over each item in an array and returns a new array containing the results of calling the 
callback function on each element. It does this without mutating the original array.

When the callback is used, it is passed three arguments. The first argument is the current element being processed. 
The second is the index of that element and the third is the array upon which the map method was called.

See below for an example using the map method on the users array to return a new array containing only the names of 
the users as elements. For simplicity, the example only uses the first argument of the callback.
    // Only change code below this line
    const ratings = watchList.map(item => ({
    title: item["Title"],
    rating: item["imdbRating"]
    }));
    // Only change code above this line

    console.log(JSON.stringify(ratings));

    Here's another example:
    const users = [
    { name: 'John', age: 34 },
    { name: 'Amy', age: 20 },
    { name: 'camperCat', age: 10 }
    ];

    const names = users.map(user => user.name);
    console.log(names);

Implement map on a Prototype
The map method returns an array of the same length as the one it was called on. It also doesn't alter the original 
array, as long as its callback function doesn't.

In other words, map is a pure function, and its output depends solely on its inputs. Plus, it takes another function 
as its argument.

You might learn a lot about the map method if you implement your own version of it. It is recommended you use a for 
loop or Array.prototype.forEach().

Write your own Array.prototype.myMap(), which should behave exactly like Array.prototype.map(). You should not use 
the built-in map method. The Array instance can be accessed in the myMap method using this.
    Array.prototype.myMap = function(callback) {
    const newArray = [];
    // Only change code below this line
    for (let i = 0; i < this.length; i++) {
        newArray.push(callback(this[i], i, this));
    }
    // Only change code above this line
    return newArray;
    };



























*/
